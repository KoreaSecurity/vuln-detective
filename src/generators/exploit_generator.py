"""Exploit generation module"""

from typing import Optional
from dataclasses import dataclass

from ..models.base import BaseModel
from ..models.factory import ModelFactory
from ..detectors.vulnerability_detector import Vulnerability


@dataclass
class Exploit:
    """Generated exploit code and documentation"""
    vulnerability: Vulnerability
    strategy: str
    code: str
    requirements: str
    expected_outcome: str
    notes: str


class ExploitGenerator:
    """Generate proof-of-concept exploits for vulnerabilities"""

    def __init__(self, model: Optional[BaseModel] = None):
        self.model = model or ModelFactory.create_advanced_model()

    async def generate(self, vulnerability: Vulnerability) -> Optional[Exploit]:
        """Generate exploit for a vulnerability"""

        prompt = f"""Generate a proof-of-concept exploit for this vulnerability:

**Vulnerability Details:**
- Type: {vulnerability.vuln_type}
- CWE: {vulnerability.cwe_id}
- Severity: {vulnerability.severity.value}
- Location: Line {vulnerability.line_number}
- Description: {vulnerability.description}

**Vulnerable Code:**
```
{vulnerability.code_snippet}
```

**Exploitability Assessment:**
{vulnerability.exploitability}

**Task:**
Create a working proof-of-concept exploit that demonstrates this vulnerability.

Provide:
1. **Exploitation Strategy** - High-level approach
2. **Requirements** - What's needed to run the exploit
3. **Exploit Code** - Complete, working code
4. **Expected Outcome** - What happens when exploit runs
5. **Notes** - Important considerations

Format as:
## Strategy
[strategy text]

## Requirements
[requirements]

## Exploit Code
```python
[code]
```

## Expected Outcome
[outcome]

## Notes
[notes]
"""

        system_prompt = """You are a security researcher creating educational proof-of-concept exploits.
Your exploits should:
- Be complete and working
- Include clear documentation
- Demonstrate the vulnerability clearly
- Be safe for testing environments
- Include appropriate warnings"""

        try:
            response = await self.model.complete(prompt, system_prompt)
            return self._parse_exploit(response.content, vulnerability)
        except Exception as e:
            print(f"Error generating exploit: {e}")
            return None

    def _parse_exploit(self, response: str, vuln: Vulnerability) -> Exploit:
        """Parse exploit from AI response"""
        sections = {
            'strategy': '',
            'requirements': '',
            'code': '',
            'outcome': '',
            'notes': ''
        }

        current_section = None
        in_code_block = False
        code_lines = []

        for line in response.split('\n'):
            line_lower = line.lower().strip()

            # Detect section headers
            if '## strategy' in line_lower:
                current_section = 'strategy'
                continue
            elif '## requirements' in line_lower:
                current_section = 'requirements'
                continue
            elif '## exploit code' in line_lower:
                current_section = 'code'
                continue
            elif '## expected outcome' in line_lower:
                current_section = 'outcome'
                continue
            elif '## notes' in line_lower:
                current_section = 'notes'
                continue

            # Handle code blocks
            if line.strip().startswith('```'):
                in_code_block = not in_code_block
                continue

            # Add content to appropriate section
            if current_section:
                if current_section == 'code':
                    if in_code_block or not line.strip().startswith('#'):
                        code_lines.append(line)
                else:
                    sections[current_section] += line + '\n'

        sections['code'] = '\n'.join(code_lines)

        return Exploit(
            vulnerability=vuln,
            strategy=sections['strategy'].strip(),
            code=sections['code'].strip(),
            requirements=sections['requirements'].strip(),
            expected_outcome=sections['outcome'].strip(),
            notes=sections['notes'].strip(),
        )

    async def generate_adaptive_exploit(
        self,
        vulnerability: Vulnerability,
    ) -> Optional[Exploit]:
        """Generate an adaptive exploit that works in different environments"""

        prompt = f"""Generate an ADAPTIVE proof-of-concept exploit that works across different environments.

**Vulnerability:**
{vulnerability.vuln_type} at line {vulnerability.line_number}

**Details:**
{vulnerability.description}

Create an exploit that:
1. Detects the environment (OS, architecture, protections)
2. Adapts its strategy based on environment
3. Includes multiple exploitation techniques
4. Handles common security mitigations (ASLR, DEP, etc.)

Provide complete Python code with environment detection and adaptation logic.
"""

        system_prompt = """You are an expert exploit developer.
Create sophisticated, adaptive exploits with proper error handling and environment awareness."""

        try:
            response = await self.model.complete(prompt, system_prompt)
            return self._parse_exploit(response.content, vulnerability)
        except Exception as e:
            print(f"Error generating adaptive exploit: {e}")
            return None
